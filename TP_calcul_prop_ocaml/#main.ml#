exception NotExhaustiveValuation;;
type formula =
  | Var of int
  | Top
  | Bot
  | Not of formula
  | Or of formula * formula
  | And of formula * formula
  | Imply of formula * formula;;

let f1 = Imply(Var(4), Imply(Imply(Var(3), Var(2)), Var(1)));;
let f2 = Or(And(Var(1), Imply(Var(2), Var(1))), Bot);;

let rec formula_height formule =
  match formule with
  | Var(id)       -> 0
  | Top           -> 0
  | Bot           -> 0
  | Not(f)        -> 1 + (formula_height f)
  | Or(f1, f2)    -> 1 + (max (formula_height f1) (formula_height f2))
  | And(f1, f2)   -> 1 + (max (formula_height f1) (formula_height f2))
  | Imply(f1, f2) -> 1 + (max (formula_height f1) (formula_height f2));;

let f1_h = formula_height f1;;
let f2_h = formula_height f2;;

let rec formula_size formule =
  match formule with
  | Var(id)       -> 1
  | Top           -> 1
  | Bot           -> 1
  | Not(f)        -> 1 + (formula_size f)
  | Or(f1, f2)    -> 1 + (formula_size f1) + (formula_size f2)
  | And(f1, f2)   -> 1 + (formula_size f1) + (formula_size f2)
  | Imply(f1, f2) -> 1 + (formula_size f1) + (formula_size f2);;

let f1_size = formula_size f1;;
let f2_size = formula_size f2;;

let rec get_value id valuation =
  match valuation with
  | [] -> raise NotExhaustiveE
  | (i, v)::tail when i = id -> v
  | hd::tail -> get_val_from_var id tail;;

let rec evaluate valuation formule =
  match formule with
  | Var(id)       -> get_value id valuation
  | Top           -> true
  | Bot           -> false
  | Not(f)        -> !(evaluate valuation f)
  | Or(f1, f2)    -> (evaluate valuation f1) || (evaluate valuation f2)
  | And(f1, f2)   -> (evaluate valuation f1) && (evaluate valuation f2)
  | Imply(f1, f2) -> !(evaluate valuation f1) || (evaluate valuation f2);;